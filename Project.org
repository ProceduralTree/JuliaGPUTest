#+title: Project Thesis
#+startup: latexpreview t
#+latex_class: mimosis
#+BIBLIOGRAPHY: ~/org/resources/bibliography/refs.bib
#+PROPERTY: header-args:julia  :eval never-export :noweb no-export :session *julia* :async t :exports results
#+latex_compiler: lualatex
#+LATEX_HEADER: \usepackage[hyperref,x11names]{xcolor}
# #+latex_header: \include{~/.config/doom/OrgConfig/noteHeader.tex}
#+latex_header: \usepackage[
#+latex_header: colorlinks = true,
#+latex_header: citecolor  = RoyalBlue,
#+latex_header: linkcolor  = RoyalBlue,
#+latex_header: urlcolor   = RoyalBlue,
#+latex_header: unicode
#+latex_header: ]{hyperref}
#+latex_header:\usepackage{fontspec}
#+latex_header: \usepackage{unicode-math}
#+latex_header: \setmonofont{DejaVu Sans Mono}[Scale=0.8]
#+options:  toc:1
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>

#+begin_abstract
This work shows sensitivity of boundary conditions for two different finite difference approaches to solving the cahn hilliard equation
#+end_abstract

* Fundamentals
The Cahn-Hilliard (CH) equation is a diffuse interface coupling equation used for interpolating between different approach in different formulas. We use it in the following form:
\begin{equation}
\begin{aligned}
\partial_{t}\phi(x,t) &=  \nabla \cdot(M(\phi)\nabla\mu) \\
\mu &= - \varepsilon^2 \Delta\phi  + W'(\phi)
\end{aligned}
\end{equation}
Furthermore our solver implements the ansatz proposed by the autors[cite:@SHIN20117441].
#+name: eq:ansatz
\begin{equation}
\begin{aligned}
\frac{\phi_{ij}^{n+1} - \phi_{ij}^n}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2}} )  \\
 \mu_{ij}^{n+\frac{1}{2}} &= 2\phi_{ij}^{n+1} - \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1} ) + W'(\phi_{ij}^n) - 2\phi _{ij}^n
\end{aligned}
\end{equation}
Although we use as slightly different implementation as in the bachelor thesis[cite:@Ulmer_CHRelaxed_2024].,  use the same discretizations and notation.

#+begin_src julia :results file :tangle src/domain.jl :file images/domain.png
using Plots
using LaTeXStrings
pgfplotsx()
Idx = CartesianIndex(1,1)
M = zeros(66,66)
M[2:end-1 , 2:end-1] = ones(64,64)
heatmap(M, title=L"\Omega_d" , clim=(0,1),
            gridlinewidth=2 , axis_equal_image=true , extra_kwargs=:subplot , xlims=(1 ,66) , ylims=(1,66), xlabel=L"x_1",ylabel=L"x_2")
#+end_src

#+RESULTS:
[[file:images/domain.png]]

#+begin_src julia :session *julia* :async t
pwd()
#+end_src

#+RESULTS:
: /home/proceduraltree/Projects/JuliaGPUTest

** Notation
We use the following differential quotients:
\begin{align}
D_xf_{i+\frac{1}{2} j} &= \frac{f_{i+1j} - f_{ij}}{h} & D_yf_{ij+\frac{1}{2}} &= \frac{f_{ij+1} - f_{ij}}{h}
\end{align}
and define a discrete gradient as.
\begin{equation}
\nabla_d f_{ij} = (D_x f_{i+1j} , \ D_y f_{ij+1})
\end{equation}
see[cite:@Ulmer_CHRelaxed_2024]
* Adaptation to second order Neumann conditions
The solver we use as reference guaranties no flux boundary conditions at a discrete level by setting \( \nabla \phi_{ij} = 0\) for \( \phi_{ij} \in \partial \Omega_{d} \) this is done by multiplying with the Characteristic function of \( \Omega_{d} \)
\begin{equation}
G_{ij}=
\begin{cases}
1 \,, x_{ij} \in \Omega \\
0 \,, x_{ij} \not\in \Omega \\
\end{cases}
\end{equation}
The accommodate different boundary conditions, we bias \( \nabla_d \cdot (G_{ij} \nabla_d \phi_{ij}) \) in grid points next to the boundary. We determine those points using a centred difference scheme on \( G \)
\begin{equation}
B_{ij} = \max\left(  |G_{i+\frac{1}{2}j} - G_{i-\frac{1}{2}j}| , |G_{ij+\frac{1}{2}} - G_{ij-\frac{1}{2}}|\right) * C
\end{equation}
where \( C \) is a constant we chose freely. For example on a 32x32 Domain with \( C=1 \) the Boundary fiels \( \mathbf{B} \) appears as follows


#+name: fig:boundary-square
#+begin_src julia :results file :file images/boundary.png
using Plots
using LaTeXStrings
using KernelAbstractions
@inline function G(I::CartesianIndex , Ids::CartesianIndices)::Float32
    Id = oneunit(I)
    if I in 2*(Ids[begin]+Id):2*(Ids[end]-Id)
        return 1
    end
    return 0
    end
include("boundary-conditions.jl")
pgfplotsx()
arr = zeros(64,64)
b = border(get_backend(arr) , 128 , size(arr))
b(arr)

heatmap(arr, title=L"\partial\Omega_d" , clim=(0,1),
            gridlinewidth=2 , axis_equal_image=true , extra_kwargs=:subplot , xlims=(1 ,64) , ylims=(1,64), xlabel=L"x_1" , ylabel=L"x_2")
#+end_src


#+caption: visualization of all grid-cells adjacent to the boundary \(\partial \Omega_{d}\) of a square domain
#+RESULTS: fig:boundary-square
[[file:images/boundary.png]]




#+name: fig:boundary-circle
#+begin_src julia :results file :file images/boundary-circle.png
@inline function G(I::CartesianIndex , Ids::CartesianIndices)::Float32
    @inline r  = Ids[end] - I
    m = maximum(Tuple(Ids[end]))
    if norm(Tuple(r)) < 0.8 * m
        return 1.
        end
    return 0.
end
using Plots
using LaTeXStrings
using KernelAbstractions
include("boundary-conditions.jl")
pgfplotsx()
arr = zeros(64,64)
b = border(get_backend(arr) , 128 , size(arr))
b(arr)

heatmap(arr, title=L"\partial\Omega_d" , clim=(0,1),
            gridlinewidth=2 , axis_equal_image=true , extra_kwargs=:subplot , xlims=(1 ,64) , ylims=(1,64), xlabel=L"x_1" , ylabel=L"x_2")
#+end_src

#+caption: visualization of all grid-cells adjacent to the boundary \(\partial \Omega_{d}\) of a circular domain
#+RESULTS: fig:boundary-circle
[[file:images/boundary-circle.png]]



We then state the adapted approach as:
\begin{equation}
\label{eq:second-order-adapted-ansatz}
\begin{aligned}
\frac{\phi_{ij}^{n+1} - \phi_{ij}^n}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2}} )  \\
 \mu_{ij}^{n+\frac{1}{2}} &= 2\phi_{ij}^{n+1} - \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1} ) + B_{ij} + W'(\phi_{ij}^n) - 2\phi _{ij}^n
\end{aligned}
\end{equation}

* Numerical solver
contrary to the solver proposed in[cite:@Ulmer_CHRelaxed_2024] we do not use a multi-grid Gauss-Seidel Solver to solve the linear system, and use a Jacoby solver instead, since it is easier to parrallize.
Similar to [cite:@Ulmer_CHRelaxed_2024] we linearise \eqref{eq:second-order-adapted-ansatz} to
\begin{equation}
\begin{aligned}
\frac{\phi_{ij}^{n+1}}{\Delta t}  -  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2}} ) &= \frac{ \phi_{ij}^n}{\Delta t}  \\
 \mu_{ij}^{n+\frac{1}{2}} - 2\phi_{ij}^{n+1} + \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1} ) + B_{ij} &=2\phi _{ij}^n - W'(\phi_{ij}^n)
\end{aligned}
\end{equation}
after some rearranging we note, that the left hand side is linear and, the right hand side is solely dependent on the previous time step. Therefore this constitutes a linear system, wich we solve with a Jacoby method, the element wise formula of wich is given as follows:
Provided the \( mth \) Jacoby iteration has been computed, the \( m+1th \) iteration is computed by solving
\begin{equation}
\begin{aligned}
\frac{\phi_{ij}^{n+1,m+1}}{\Delta t}  -  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2},m+\frac{1}{2}} ) &= \frac{ \phi_{ij}^{n}}{\Delta t}  \\
 \mu_{ij}^{n+\frac{1}{2},m} - 2\phi_{ij}^{n+1,m} + \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1,m+\frac{1}{2}} ) + B_{ij} &=2\phi _{ij}^n - W'(\phi_{ij}^n)
\end{aligned}
\end{equation}
for \( \phi_{ij}^{n+1,m+1} , \mu_{ij}^{n+\frac{1}{2},m+1} \),
where \( \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2},m+\frac{1}{2}} ) \) and \( \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1,m+\frac{1}{2}} ) \).  Use the results from the previous jacoby step for values off the center. eg.
\begin{equation}
\begin{aligned}
 \nabla _d \cdot (G_{ij} \nabla_d \phi_{ij}^{n+1,m+\frac{1}{2}} )  =&
\frac{1}{h^2} (
G_{i+\frac{1}{2}j}\phi_{i+1j}^{n+1,m}
+ G_{i-\frac{1}{2}j}\phi_{i-1j}^{n+1,m} \\
& + \quad G_{ij+\frac{1}{2}}\phi_{ij+1}^{n+1,m}
+ G_{ij-\frac{1}{2}}\phi_{ij-1}^{n+1,m}
 ) \\
& -
\left(
 G_{i+\frac{1}{2}j}
 + G_{i-\frac{1}{2}j}
 + G_{ij+\frac{1}{2}}
 + G_{ij-\frac{1}{2}}
\right)\phi_{ij}^{n+1,m+1}
\end{aligned}
\end{equation}
our implementation makes use of julia to dispatch the solution for each element in paralell on the GPU. The full implementation of the jacoby iteration is given as:
#+begin_src julia :eval never :exports code
@kernel function jacoby!(
    Φ,
    M,
    @Const(Ξ),
    @Const(Ψ),
    @Const(h),
    @Const(ε),
    @Const(Δt),
    @Const(iterations)
)
    I   = @index(Global, Cartesian)
    Id  = oneunit(I)
    Ids = CartesianIndices(M)
    Ix = CartesianIndex(1, 0)
    Iy = CartesianIndex(0, 1)
    if I in (Ids[begin]+Id:Ids[end]-Id)
        g = G(2 * I + Ix, Ids) + G(2 * I + Iy, Ids) + G(2 * I - Ix, Ids) + G(2 * I - Iy, Ids)
        a1 = 1/Δt
        a2 = -1* ε^2/h^2 * g  - 2
        b1 = 1/h^2 * g
        b2 = 1
        for _ = 1:iterations

            Σμ = G(2 * I + Ix, Ids) * M[I+Ix] + G(2 * I + Iy, Ids) * M[I+Iy] + G(2 * I - Ix, Ids) * M[I-Ix] + G(2 * I - Iy, Ids) * M[I-Iy]

            Σϕ = G(2 * I + Ix, Ids) * Φ[I+Ix] + G(2 * I + Iy, Ids) * Φ[I+Iy] +G(2 * I - Ix, Ids) * Φ[I-Ix] +G(2 * I - Iy, Ids) * Φ[I-Iy]

            c1 = Ξ[I] + 1/h^2   * Σμ
            c2 = Ψ[I] - ε^2/h^2 * Σϕ

            # stupid matrix solve
            @inline Φ[I] = (c1*b2 - c2*b1) / (a1*b2 - a2*b1)
            @inline M[I] = (a1*c2 - a2*c1) / (a1*b2 - a2*b1)
            #
            @synchronize()
        end

    end
end
#+end_src


* Numerical evaluation
** Experiments
to begin our evaluations we tested constant values for \( B_{ij} \) on the boundary.
initially we tested setting \(C=0\) as it is equivalent to the no-flux boundary condition of the unmodified solver. For \( C = 0 \) ,as seen in [[fig:angle0,]] the interface lies orthogonal on the boundary as expected for a CH solver with no-flux boundary conditions.
For \( B_{ij} \in \{-1,1\} \) we observed behaviour expected of hydrophobic / hydrophilic substances on the boundary, where \( B_{ij}=1 \) resulted in the one phase pearling of the boundary, while the other semed attracted. this manifested on apparent contact angles of 180° and 0° respectivly. Using \( B_{ij} = -1 \) results in the opposite behavior.


#+name: fig:angle0
#+begin_src julia  :exports results :results file :file images/baseline.png
include("solvers.jl")
include("initial_conditions.jl")
arr = _init()
θ = 0
n = 100
solution = solve(arr , n , θ=θ)
gr()
heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
title!(L"$\Phi$  after $%$n$ time-steps")
xlabel!(L"i")
ylabel!(L"j")
#+end_src

#+caption: phase-field \( \phi \) after 100 time-steps with \( C=0 \) emmulating no-flux boundary.
#+RESULTS: fig:angle0
[[file:images/baseline.png]]

To showcase the relative stability, and the effect off the constant boundary proposed in TODO we evaluate our solver with different constant values \(C\). In [[fig:angle1]] we employ a constant value of \(C=1\) and observe the phase corresponding to \(\phi = 1\) puling away from the boundary. the contact angle between phase 1 and the boundary approaches 180° ie. the interface runs parallel to the boundary.
#+name: fig:angle1
#+begin_src julia  :results file :file images/angle1.png
θ = 1f0
n = 500
solution = solve(arr , n , θ=θ)
heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
title!(L"$\Phi$  after $%$n$ time-steps")
xlabel!(L"i")
ylabel!(L"j")
#+end_src

#+RESULTS: fig:angle1
[[file:images/angle1.png]]


In [[fig:angle-1]] we try the opposite as bevore. And we obsesrve corresponding behaviour. When using a value of \(C=-1\) we observe behaviour opposite to before. Where the contact angle on the boundary lies at 0°, the interface runs parallel to the boundary again.
#+name: fig:angle-1
#+begin_src julia :results file :file images/angle-.png
include("solvers.jl")
θ = -1f-0
arr = _init()
n = 500
solution = solve(arr , n , θ=θ ,arrtype=cu)
heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
title!(L"$\Phi$  after $%$n$ time-steps")
xlabel!(L"i")
ylabel!(L"j")
#+end_src

#+caption: phase-field \( \phi \) after 100 time-steps with \( C=-1 \)
#+RESULTS: fig:angle-1
[[file:images/angle-.png]]

we observe the most interessting behaviour for values between \((-1,1)\), where we observe the contact angle of the interafce on the boundary to change from parallel 0° to parallel 180°.
#+name: fig:angle-sqrt(2)
#+begin_src julia :results file :file images/angle-sqrt(2).png
include("solvers.jl")
angles = Float32.([-1+sqrt(2)/2, -0.5 , 0.5 , 1-sqrt(2)/2])
arr = _init()
n = 100
plots = []
for a in angles
    solution = solve(arr , n , θ=a)
    h = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
    title!(h,L" C=%$a")
    xlabel!(h,L"i")
    ylabel!(h,L"j")
    push!(plots, h)
end
plot(plots...)
#+end_src

#+caption: phase-field \( \phi \) after 500 time-steps with \(C \in \{-1 + \frac{\sqrt{2}}{2} , -0.5 , 0.5 , 1 - \frac{\sqrt{2}}{2} \}\)
#+RESULTS: fig:angle-sqrt(2)
[[file:images/angle-sqrt(2).png]]

#+name: fig:random-square
#+begin_src julia    :exports both
using LaTeXStrings
include("solvers.jl")
θ = 5f-3
arr = cu(rand(Float32,256,256)) .* 2 .- 1
d = domain(get_backend(arr) , 256 , size(arr))
d(arr)
solution = solve(arr , 5 , θ=θ)
h1 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=5")
solution = solve(arr , 50 , θ=θ)
h2 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=50")
solution = solve(arr , 500 , θ=θ)
h3 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=500")
solution = solve(arr , 5000 , θ=θ)
h4 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=5000")
plot(h1,h2,h3,h4)
#+end_src

#+caption: phase-field \( \phi \) after 100 time-steps with \( C=-\frac{\sqrt{2}}{2} \)
#+RESULTS: fig:random-square
[[file:/tmp/babel-g07KfA/julia-rwA51y.png]]



** more values
further testing shows that with values for \( B_{ij} \in [-1,1] \) we are able to control the contact angle freely.
** Boundary Normals
we are interested in the contact angle of the interface on the boundary. ie.
\begin{align}
\label{eq:1}
\frac{\nabla_d \phi_{ij} \cdot \mathbf{n}}{\|\nabla_{d} \phi_{ij}\|} &= \cos(\theta)& & \phi_{ij} \in \partial\Omega_{d} = 0
\end{align}
ie.
\begin{align}
\frac{\nabla_d \phi_{ij} \cdot \mathbf{n}}{\|\nabla_{d} \phi_{ij}\|} - \cos(\theta) &= 0 \\
\frac{\nabla_d \phi_{ij} \cdot \mathbf{n}}{\|\nabla_{d} \phi_{ij}\|} - \cos(\theta) \mathbf{n} \cdot \mathbf{n} &= 0 \\
\left(   \frac{\nabla_d \phi_{ij}}{\|\nabla_{d} \phi_{ij}\|} - \cos(\theta) \mathbf{n} \right) \cdot \mathbf{n} &= 0 \\
\left(   \nabla_d \phi_{ij}- \cos(\theta) \|\nabla_{d} \phi_{ij}\|  \mathbf{n} \right) \cdot \mathbf{n} &= 0 \\
\end{align}
therefore we use
\begin{align}
\nabla \cdot \left(   \nabla_d \phi_{ij}- \cos(\theta) \|\nabla_{d} \phi_{ij}\|  \mathbf{n} \right) \cdot \mathbf{n} &= \nabla \cdot \nabla \phi_{ij} - \cos(\theta) div(\mathbf{n})\\
\end{align}
in our implementation we modify \( \nabla_d (G \nabla_d \phi_{ij})\).
In essence our solver tries to ensure no flux boundary conditions ie. \( \nabla \phi_{ij} \cdot \mathbf{n} = 0 \).
hence \( B_{ij} \) should be \( -\cos(\theta) \left| \nabla_d \phi_{ij}   \right|  div(\mathbf{n}) \)


* Numerical evaluation on a circle
** Experiments
The original solver presented in[cite:@SHIN20117441]  was able to solve the CH equation on arbitrary domains. Since the addition of our boundary function depends soley on the characteristic function of the discrete domain, we are able to use our approach on diferent Domains, by providing a different characteristic function. We present the results of which in this chapter.
To show the behavior of the CH sover in [[fig:angle0c]], we first emplay no-flux boundary conditioons on a circular domain. We \ref{eq:01}  observe the interface perpendicular on the boundary, ans we expect.

#+begin_src julia
@inline function G(I::CartesianIndex , Ids::CartesianIndices)::Float32
    @inline r  = Ids[end] - I
    m = maximum(Tuple(Ids[end]))
    if norm(Tuple(r)) < 0.8 * m
        return 1.
        end
    return 0.
end
#+end_src


#+name: fig:angle0c
#+begin_src julia  :exports results :results file :file images/angle0c.png
include("solvers.jl")
include("initial_conditions.jl")
arr = _init()
d = domain(get_backend(arr) , 128 , size(arr))
θ = 0
solution = solve(arr , 100 , θ=θ)
heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
#+end_src

#+caption: \(\phi\) after 100 time steps on a circular domain with no-flux boundary-conditions after 100 time steps on a circular domain with no-flux boundary-conditions
#+RESULTS: fig:angle0c
[[file:images/angle0c.png]]




#+name: fig:angle1c
#+begin_src julia  :exports both :results drawer :wrap figure
θ = -2f-2
solution = solve(arr , 100 , θ=θ)
heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
#+end_src

#+RESULTS: fig:angle1c
#+begin_figure
[[file:./.ob-julia-snail/jl_rQvSDEnExA.png]]
#+end_figure

#+caption: phase-field \( \phi \) after 100 time-steps with \( C=1 \)

#+name: fig:angle-1c
#+begin_src julia   :results drawer :exports both
include("solvers.jl")
θ = -1f-0
arr = _init()
solution = solve(arr , 100 , θ=θ ,arrtype=cu)
heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
#+end_src

#+RESULTS: fig:angle-1c
#+begin_results
[[file:./.ob-julia-snail/jl_54rwjYv0ja.png]]
#+end_results

#+caption: phase-field \( \phi \) after 100 time-steps with \( C=-1 \)

#+name: fig:angle-sqrt(2)c
#+begin_src julia   :results drawer :exports both :async t
include("solvers.jl")
θ = Float32(-sqrt(2)/2)
solution = solve(arr , 100 , θ=θ)
heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06)
#+end_src

#+RESULTS: fig:angle-sqrt(2)c
#+begin_results
[[file:./.ob-julia-snail/jl_F6fGfCLCDA.png]]
#+end_results

#+caption: phase-field \( \phi \) after 100 time-steps with \( C=-\frac{\sqrt{2}}{2} \)

#+name: fig:random-circle
#+begin_src julia   :results drawer :exports both :wrap figure
using LaTeXStrings
include("solvers.jl")
θ = 5f-3
arr = cu(rand(Float32,256,256)) .* 2 .- 1
d = domain(get_backend(arr) , 256 , size(arr))
d(arr)
solution = solve(arr , 5 , θ=θ)
h1 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=5")
solution = solve(arr , 50 , θ=θ)
h2 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=50")
solution = solve(arr , 500 , θ=θ)
h3 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=500")
solution = solve(arr , 5000 , θ=θ)
h4 = heatmap(Array(solution) , aspect_ratio=:equal , clims=(-1,1), lims=(0,size(solution,1)), widen=1.06 , title=L"n=5000")
plot(h1,h2,h3,h4)
#+end_src

#+caption: phase-field \( \phi \) after 100 time-steps with \( C=-\frac{\sqrt{2}}{2} \)

#+RESULTS: fig:random-circle
#+begin_results
[[file:./.ob-julia-snail/jl_bapARITWtE.png]]
#+end_results

** more values
further testing shows that with values for \( B_{ij} \in [-1,1] \) we are able to control the contact angle freely.
** Boundary Normals :noexport:
we are interested in the contact angle of the interface on the boundary. ie.
\begin{align}
\frac{\nabla_d \phi_{ij} \cdot \mathbf{n}}{\|\nabla_{d} \phi_{ij}\|} &= \cos(\theta)& & \phi_{ij} \in \partial\Omega_{d} = 0
\end{align}
ie.
\begin{align}
\frac{\nabla_d \phi_{ij} \cdot \mathbf{n}}{\|\nabla_{d} \phi_{ij}\|} - \cos(\theta) &= 0 \\
\frac{\nabla_d \phi_{ij} \cdot \mathbf{n}}{\|\nabla_{d} \phi_{ij}\|} - \cos(\theta) \mathbf{n} \cdot \mathbf{n} &= 0 \\
\left(   \frac{\nabla_d \phi_{ij}}{\|\nabla_{d} \phi_{ij}\|} - \cos(\theta) \mathbf{n} \right) \cdot \mathbf{n} &= 0 \\
\left(   \nabla_d \phi_{ij}- \cos(\theta) \|\nabla_{d} \phi_{ij}\|  \mathbf{n} \right) \cdot \mathbf{n} &= 0 \\
\end{align}
therefore we use
\begin{align}
\nabla \cdot \left(   \nabla_d \phi_{ij}- \cos(\theta) \|\nabla_{d} \phi_{ij}\|  \mathbf{n} \right) \cdot \mathbf{n} &= \nabla \cdot \nabla \phi_{ij} - \cos(\theta) div(\mathbf{n})\\
\end{align}
in our implementation we modify \( \nabla_d (G \nabla_d \phi_{ij})\).
In essence our solver tries to ensure no flux boundary conditions ie. \( \nabla \phi_{ij} \cdot \mathbf{n} = 0 \).
hence \( B_{ij} \) should be \( -\cos(\theta) \left| \nabla_d \phi_{ij}   \right|  div(\mathbf{n}) \)

* Summary and outlook
* References
#+PRINT_BIBLIOGRAPHY:

# Local Variables:
# #julia-snail-extensions: (ob-julia)
# #julia-snail/ob-julia-capture-io: nil
# End:
